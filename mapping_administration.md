
# How mappings works

### Retrieving mappings

See `self.mappings_ontologies` in ontologies_linked_data/mappings/mappings.rb:
https://github.com/ncbo/ontologies_linked_data/blob/master/lib/ontologies_linked_data/mappings/mappings.rb#L159

There is one big SPARQL query to get all mappings directly from 4store

* ?s1 can be replaced by a class URI to get all the mappings from this particular class
* ?g can be replaced by a submission graph (if we want to see mappings between 2 specific ontologies) 

```sql
SELECT DISTINCT ?s1 ?s2  ?source ?o
WHERE {
{
  GRAPH <http://data.bioontology.org/ontologies/BHN/submissions/1> {
      ?s1 <http://bioportal.bioontology.org/ontologies/umls/cui> ?o .
  }
  GRAPH ?g {
      ?s2 <http://bioportal.bioontology.org/ontologies/umls/cui> ?o .
  }
  BIND ('CUI' AS ?source)
}

UNION
{
  GRAPH <http://data.bioontology.org/ontologies/BHN/submissions/1> {
      ?s1 <http://data.bioontology.org/metadata/def/mappingSameURI> ?o .
  }
  GRAPH ?g {
      ?s2 <http://data.bioontology.org/metadata/def/mappingSameURI> ?o .
  }
  BIND ('SAME_URI' AS ?source)
}

UNION
{
  GRAPH <http://data.bioontology.org/ontologies/BHN/submissions/1> {
      ?s1 <http://data.bioontology.org/metadata/def/mappingLoom> ?o .
  }
  GRAPH ?g {
      ?s2 <http://data.bioontology.org/metadata/def/mappingLoom> ?o .
  }
  BIND ('LOOM' AS ?source)
}

UNION
{
  GRAPH <http://data.bioontology.org/ontologies/BHN/submissions/1> {
      ?s1 <http://data.bioontology.org/metadata/def/mappingRest> ?o .
  }
  GRAPH ?g {
      ?s2 <http://data.bioontology.org/metadata/def/mappingRest> ?o .
  }
  BIND ('REST' AS ?source)
}

FILTER ((?s1 != ?s2) || (?source = 'SAME_URI'))
} OFFSET 0 LIMIT 50
```

After mappings have been retrieved they are represented using **LinkedData::Models::Mapping**. But it is not hard stored on the triplestore.

### Examples of mapping properties

* **SameURI**: point to the subject URI
`<http://purl.bioontology.org/ontology/STY/T071> <http://data.bioontology.org/metadata/def/mappingSameURI> <http://purl.bioontology.org/ontology/STY/T071> .`

* **LOOM**: point to a simplified string of the ontology. Removing all special characters, space and characters with accents to make the string comparison
`<http://purl.obolibrary.org/obo/PR_O09117-2> <http://data.bioontology.org/metadata/def/mappingLoom> "hyperesthsiedespieds"`


* **CUI**: a unique property URI (generated by the umls2rdf.py script) point to the CUI. And the Portal is checking at this property to compare the CUIs.
`<http://purl.lirmm.fr/ontology/MSHFRE/D011537> <http://bioportal.bioontology.org/ontologies/umls/cui> "C0033774"`


* **RestBackupMapping**: point to the URI of a RestBackupMapping
`<http://purl.bioontology.org/ontology/STY/T071> <http://data.bioontology.org/metadata/def/mappingRest> <http://data.bioontology.org/rest_backup_mappings/d5717dc0-74d7-0133-187d-525400037747>`


### Manual mappings are composed of

* LinkedData::Models::**RestBackupMapping**
    * uuid (unique id)
    * Class URNs
    * Mapping Process (see below)

* LinkedData::Models::**MappingProcess**
    * Name, source, relation, comment, date, creator...

* Link between the class URI and the RestBackupMapping
For instance: `<http://purl.bioontology.org/ontology/STY/T071> <http://data.bioontology.org/metadata/def/mappingRest> <http://data.bioontology.org/rest_backup_mappings/8068efe0-d4af-0133-0923-525400037747>`


* LinkedData::Models::**MappingCount**
Just to store the number of mappings between 2 ontologies or for 1 ontology



### Problem: the mapping object is fragmented
If we want to delete a mapping we have to:

* Delete the MappingProcess
* Delete the link between the mapped class URI and the RestBackupMapping (directly using a sparql_update_client... So not using the models)
* Delete the RestBackupMapping

```ruby
# Deleting link between class URI and RestBackupMapping
classes.each do |class|
      graph_delete = RDF::Graph.new
      graph_delete << [class.id, RDF::URI.new(rest_predicate), mapping.id]
      Goo.sparql_update_client.delete_data(graph_delete, graph: submission.id)
end
```


### Retrieving Recent mappings

2 SPARQL queries
https://github.com/ncbo/ontologies_linked_data/blob/master/lib/ontologies_linked_data/mappings/mappings.rb#L504

* Retrieving the most recent mappings ID (can take a lot of time if a lot of mappings)

```sql
SELECT DISTINCT ?s
FROM <http://data.bioontology.org/metadata/MappingProcess>
WHERE { ?s <http://data.bioontology.org/metadata/date> ?o }
ORDER BY DESC(?o) LIMIT 5
```

* Getting details on those recent mappings
In the last filter "procs" is replaced by `?o = <MappingProcess URI> || ?o = <MappingProcess URI> || etc...`

```sql
SELECT DISTINCT ?ont1 ?c1 ?ont2 ?c2 ?o ?uuid
WHERE {
  ?uuid <http://data.bioontology.org/metadata/process> ?o .

  ?s1 <http://data.bioontology.org/metadata/ontology> ?ont1 .
  GRAPH ?s1 {
    ?c1 <http://data.bioontology.org/metadata/def/mappingRest> ?uuid .
  }
  ?s2 <http://data.bioontology.org/metadata/ontology> ?ont2 .
  GRAPH ?s2 {
    ?c2 <http://data.bioontology.org/metadata/def/mappingRest> ?uuid .
  }
FILTER(?ont1 != ?ont2)
FILTER(?c1 != ?c2)
FILTER (#{procs})
}
```




<br>
<br>
<br>

#But : Supprimer tous les mappings liés à une ontology

## Delete all mappings linked to an ontology

Change `acronym` par l'acronym de l'ontology qu'on cible

bin/ncbo_cron --console

```ruby
acronym = "MUEVO"
LinkedData::Models::RestBackupMapping.all.each do |m|
  mapping_id = RDF::URI.new(m.id.to_s)
  begin
    backup = LinkedData::Models::RestBackupMapping.find(mapping_id).include(:class_urns).first
    backup.class_urns.each do |urn|
      if urn.split(":")[1] == acronym
        puts "Deleting: #{urn}"
        deleted_mapping = LinkedData::Mappings.delete_rest_mapping(mapping_id)
        puts "#{deleted_mapping} has been deleted"
      end
    end
  rescue
    puts "DELETE #{m.id.to_s} FAILED"
    next
  end
end
```


## Exemple résoudre bug où liens entre backup et cls n'ont pas été coupés

On vire tous les backup liés à MUEVO submission 1

```ruby
qmappings = <<-eos
SELECT DISTINCT ?uuid ?c1 ?c2 ?s2
WHERE {
  GRAPH <http://data.bioontology.org/ontologies/MUEVO/submissions/1> {
    ?c1 <http://data.bioontology.org/metadata/def/mappingRest> ?uuid .
  }
  GRAPH ?s2 {
    ?c2 <http://data.bioontology.org/metadata/def/mappingRest> ?uuid .
  }
} LIMIT 10000
eos
epr = Goo.sparql_query_client(:main)
epr.query(qmappings,
          graphs: [RDF::URI.new("http://data.bioontology.org/ontologies/MUEVO/submissions/1")]).each do |sol|
  graph_delete = RDF::Graph.new
  graph_delete << [RDF::URI.new(sol[:c1].to_s), RDF::URI.new("http://data.bioontology.org/metadata/def/mappingRest"), RDF::URI.new(sol[:uuid].to_s)]
  Goo.sparql_update_client.delete_data(graph_delete, graph: RDF::URI.new("http://data.bioontology.org/ontologies/MUEVO/submissions/1"))
  puts "DELETED : #{sol[:c1]} -- #{sol[:uuid]}"
  sleep 0.2
  graph_delete = RDF::Graph.new
  graph_delete << [RDF::URI.new(sol[:c2].to_s), RDF::URI.new("http://data.bioontology.org/metadata/def/mappingRest"), RDF::URI.new(sol[:uuid].to_s)]
  Goo.sparql_update_client.delete_data(graph_delete, graph: RDF::URI.new(sol[:s2].to_s))
  puts "DELETED : #{sol[:c2]} -- #{sol[:uuid]}"
  sleep 0.2
end
```